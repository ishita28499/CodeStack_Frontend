{"ast":null,"code":"// http://jsfiddle.net/danmana/5mNNU/\nconst htmlSubstring = (s, n) => {\n  var m,\n      r = /<([^>\\s]*)[^>]*>/g,\n      stack = [],\n      lasti = 0,\n      result = ''; //for each tag, while we don't have enough characters\n\n  while ((m = r.exec(s)) && n) {\n    //get the text substring between the last tag and this one\n    var temp = s.substring(lasti, m.index).substr(0, n); //append to the result and count the number of characters added\n\n    result += temp;\n    n -= temp.length;\n    lasti = r.lastIndex;\n\n    if (n) {\n      result += m[0];\n\n      if (m[1].indexOf('/') === 0) {\n        //if this is a closing tag, than pop the stack (does not account for bad html)\n        stack.pop();\n      } else if (m[1].lastIndexOf('/') !== m[1].length - 1) {\n        //if this is not a self closing tag than push it in the stack\n        stack.push(m[1]);\n      }\n    }\n  } //add the remainder of the string, if needed (there are no more tags in here)\n\n\n  result += s.substr(lasti, n); //fix the unclosed tags\n\n  while (stack.length) {\n    result += '</' + stack.pop() + '>';\n  }\n\n  return result;\n};\n\nexport default htmlSubstring;","map":{"version":3,"names":["htmlSubstring","s","n","m","r","stack","lasti","result","exec","temp","substring","index","substr","length","lastIndex","indexOf","pop","lastIndexOf","push"],"sources":["C:/Users/ISHITA/Downloads/Atul/Frontend/src/services/htmlSubstring.js"],"sourcesContent":["// http://jsfiddle.net/danmana/5mNNU/\nconst htmlSubstring = (s, n) => {\n    var m, r = /<([^>\\s]*)[^>]*>/g,\n        stack = [],\n        lasti = 0,\n        result = '';\n\n    //for each tag, while we don't have enough characters\n    while ((m = r.exec(s)) && n) {\n        //get the text substring between the last tag and this one\n        var temp = s.substring(lasti, m.index).substr(0, n);\n        //append to the result and count the number of characters added\n        result += temp;\n        n -= temp.length;\n        lasti = r.lastIndex;\n\n        if (n) {\n            result += m[0];\n            if (m[1].indexOf('/') === 0) {\n                //if this is a closing tag, than pop the stack (does not account for bad html)\n                stack.pop();\n            } else if (m[1].lastIndexOf('/') !== m[1].length - 1) {\n                //if this is not a self closing tag than push it in the stack\n                stack.push(m[1]);\n            }\n        }\n    }\n\n    //add the remainder of the string, if needed (there are no more tags in here)\n    result += s.substr(lasti, n);\n\n    //fix the unclosed tags\n    while (stack.length) {\n        result += '</' + stack.pop() + '>';\n    }\n\n    return result;\n\n}\n\nexport default htmlSubstring;"],"mappings":"AAAA;AACA,MAAMA,aAAa,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;EAC5B,IAAIC,CAAJ;EAAA,IAAOC,CAAC,GAAG,mBAAX;EAAA,IACIC,KAAK,GAAG,EADZ;EAAA,IAEIC,KAAK,GAAG,CAFZ;EAAA,IAGIC,MAAM,GAAG,EAHb,CAD4B,CAM5B;;EACA,OAAO,CAACJ,CAAC,GAAGC,CAAC,CAACI,IAAF,CAAOP,CAAP,CAAL,KAAmBC,CAA1B,EAA6B;IACzB;IACA,IAAIO,IAAI,GAAGR,CAAC,CAACS,SAAF,CAAYJ,KAAZ,EAAmBH,CAAC,CAACQ,KAArB,EAA4BC,MAA5B,CAAmC,CAAnC,EAAsCV,CAAtC,CAAX,CAFyB,CAGzB;;IACAK,MAAM,IAAIE,IAAV;IACAP,CAAC,IAAIO,IAAI,CAACI,MAAV;IACAP,KAAK,GAAGF,CAAC,CAACU,SAAV;;IAEA,IAAIZ,CAAJ,EAAO;MACHK,MAAM,IAAIJ,CAAC,CAAC,CAAD,CAAX;;MACA,IAAIA,CAAC,CAAC,CAAD,CAAD,CAAKY,OAAL,CAAa,GAAb,MAAsB,CAA1B,EAA6B;QACzB;QACAV,KAAK,CAACW,GAAN;MACH,CAHD,MAGO,IAAIb,CAAC,CAAC,CAAD,CAAD,CAAKc,WAAL,CAAiB,GAAjB,MAA0Bd,CAAC,CAAC,CAAD,CAAD,CAAKU,MAAL,GAAc,CAA5C,EAA+C;QAClD;QACAR,KAAK,CAACa,IAAN,CAAWf,CAAC,CAAC,CAAD,CAAZ;MACH;IACJ;EACJ,CAzB2B,CA2B5B;;;EACAI,MAAM,IAAIN,CAAC,CAACW,MAAF,CAASN,KAAT,EAAgBJ,CAAhB,CAAV,CA5B4B,CA8B5B;;EACA,OAAOG,KAAK,CAACQ,MAAb,EAAqB;IACjBN,MAAM,IAAI,OAAOF,KAAK,CAACW,GAAN,EAAP,GAAqB,GAA/B;EACH;;EAED,OAAOT,MAAP;AAEH,CArCD;;AAuCA,eAAeP,aAAf"},"metadata":{},"sourceType":"module"}